---
title: 백엔드 엔지니어로 살아남기
tags:
  - software-engineering
  - software-engineer
---

# 백엔드 엔지니어로 살아남기

처음 코딩을 한 건 2007년, 중학교 1학년 때였던 것 같다. HTML이나 JS 같은 여러 개념들을 전혀 모르고 있던 시절 우연히 `<marquee>` 태그를 인터넷에서 접하게 되었다. 딱딱했던 글자들이 물 흐르듯 역동성을 띄게 되는 것이 신기했었는지 학교 게시판에 제목이 왼쪽에서 오른쪽으로 흐르는 글을 작성해보았다. 반응은 폭발적. 웹이 이제 활성화 되던 그 당시에 친구들은 어떻게 했는지 물어보았고, 나는 영엽비밀이라고 알려주지 않았다. 이후 더 재미난 것이 없나 찾아보던 중 `alert()`와 `for`문을 접하게 되었고 내 글에 접속하면 *"1000번 클릭하세요!"* 라는 알림창을 1000번 클릭해야 정상적인 브라우저 이용이 가능하도록 보기 좋게 선생님과 친구들을 골탕 먹였던 게 생각난다. 나중에 시간이 오래 지나고 그게 **XSS 공격**이라고 불린다는 걸 알게 되었다.

순전히 호기심과 장난으로 시작했던 코딩을 아직까지 하고 있다니. 지금은 2년차에 접어든 백엔드 엔지니어. 그동안 겪은 성장의 연속 속에서 소위 말하는 '패러다임의 전환'을 몇 번 맞딱드렸던 것 같다. 굳이 다섯 개 정도를 꼽아보자면 첫 번째는 **서버-클라이언트 아키텍처**를 이해했을 때, 두 번째는 **가상메모리**(virtual memory)의 원리를 깨달았을 때, 세 번째는 **캐싱**(caching)이 두 가치의 trade-off를 효율적으로 관리하기 위한 전략이란 것을 알게 되었을 때, 네 번째는 **추상화**(abstraction)라는 것이 CS 온갖 곳에 적용되어 있는 근본 원리라는 것을 자각했을 때, 마지막은 결국 소프트웨어 엔지니어링은 단순 프로그래밍이 아닌, 결국 **협업**과 **커뮤니케이션**에 대해 얘기하는 분야라는 것을 받아들이게 되었을 때 정도가 될 것이다.

2년차 개발자가 되니 이 다섯 개의 개념 모두 사실 같은 것을 얘기하고 있다는 생각이 들게 되었다. 아직은 모호하고 추상적인 이 얘기를 한번 정리해보자는 의미에서 (2년차 개발자의) '백엔드 엔지니어로 살아남기' 글을 써본다.

## 사실 컴퓨터는 별 게 없다

사실 컴퓨터는 별 게 없다. [폰 노이만 구조](https://en.wikipedia.org/wiki/Von_Neumann_architecture)로 설명해보자면, 컴퓨터에는 0과 1로 이루어진 데이터를 보관할 수 있는 메모리가 있고 이 메모리에서 원하는 위치에 보관되어 있는 데이터를 읽고 또 원하는 위치에 데이터를 쓸 수 있는 CPU가 있다. CPU는 ALU라는 계산기를 갖고 있어서 읽어온 데이터를 서로 더하고 빼는 등 일들을 할 수 있다. 이게 끝이다. 소프트웨어 엔지니어가 할 일은 이 메모리에 초기 데이터(소프트웨어)를 적절히 넣어주기만 하면 된다. 오토마타 이론에 나오는 FSM이나 튜링기계(무한한 테이프가 나오는 그것) 따위의 추상적이고 다분히 수학적인 구조들과 결국 똑같은 기계일 뿐이다.

우리가 원하는 결과를 계산하기 위해, 우리가 의도한 서비스를 제공하기 위해 우리는 우리가 의도한 결과를 낼 수 있는 초기 데이터(소프트웨어)를 컴퓨터에게 제공하면 된다. 그럼 컴퓨터는 초당 수십 억 번의 계산을 우리가 정한 규칙에 맞게 수행할 것이다. 소프트웨어를 만든다는 것은 상태기계의 관점에서 로직을 수행하는 transition rule을 제공하는 것 이상도 이하도 아닐 것이다. 이 과정을 '프로그래밍'이라 부를 수 있으려나.

그러나 transition rule을 제공하는 프로세스에서는 '나'라는 새로운 객체가 등장한다. '나'와 '컴퓨터' 사이의 커뮤니케이션을 원활하게 이룰 수 있으려면 고려해야 할 것들이 한두 가지가 아닐 터. 몇 가지 떠오르는 것들을 적어보았다.

- 내가 원하는 것을 이루기 위해 어떻게 로직을 짤 수 있을까?
- 내 머릿속에 구상한 로직을 어떻게 '프로그래밍'해야 하는가?
- 컴퓨터가 내가 의도한대로 작동할 것이란 보장이 있는가?
- 컴퓨터는 내가 원하는 시간 안에 작업을 완료할 수 있는가?
- 컴퓨터를 바꿔도 내 소프트웨어는 계속 작동할까?

보통 의도를 수행할 로직을 떠올리고 이 로직이 수행되는 시간적 효율성을 따지는 일들을 **알고리즘** 분야에서 다룬다. 논리학과 수학







#### 키워드

- 모든 시스템은 실패한다
- scailing, clustering, sharding
- vcs
- devops, ci, cd